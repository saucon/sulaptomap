package converter

import (
	"bytes"
	"errors"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
	"unicode"
)

var (
	DefaultOptions = Options{
		SnakeCase: true,
		IgnoreObj: true,
	}
)

type Options struct {
	SnakeCase bool
	IgnoreObj bool
}

type TemplatePlaceholder struct {
	PackageName      string
	StructName       string
	StructPrefixName string
	StructFieldLen   int
	Fields           []Field
}
type Field struct {
	Name            string
	MapKey          string
	CheckZeroOrNil  string
	Dereference     string
	GureguNullValue string
	IsObj           bool
}

// templateString is the template for generating the ToMap function.
const templateMethodMapTo = `
// generated by sulaptomap. It's oke to modify, don't be shy.
package {{.PackageName}}

func ({{.StructPrefixName}} *{{.StructName}}) ToMap(mapper map[string]any) {
{{- $prefix := .StructPrefixName -}}
	{{range .Fields}}
		{{if not .IsObj}}
		if {{$prefix}}.{{.Name}}{{ .CheckZeroOrNil}} { 
			mapper["{{.MapKey}}"] = {{.Dereference}}{{$prefix}}.{{.Name}}{{.GureguNullValue}}
		}
		{{end}}
	{{end}}
}

func ({{.StructPrefixName}} *{{.StructName}}) FieldsLen() int {
	return {{.StructFieldLen}} 
}
`

func ConvertToMap(structName string, sourceFile string, opts *Options) (err error) {
	node, err := readSourceFile(sourceFile)
	if err != nil {
		return err
	}

	holder := parseToTemplate(structName, node, opts)
	err = writeHolderToFile(holder, sourceFile)
	if err != nil {
		return err
	}

	return nil
}

func readSourceFile(sourceFile string) (node *ast.File, err error) {
	fs := token.NewFileSet()
	node, err = parser.ParseFile(fs, sourceFile, nil, parser.AllErrors)
	if err != nil {
		err = errors.New("Error parsing source file: " + err.Error())
		return nil, err
	}

	return node, nil
}

func parseToTemplate(structName string, node *ast.File, opts *Options) (holder TemplatePlaceholder) {
	structs := map[string]*ast.StructType{}
	for i, _ := range node.Decls {
		switch node.Decls[i].(type) {
		case *ast.GenDecl:
			for _, spec := range node.Decls[i].(*ast.GenDecl).Specs {
				switch spec.(type) {
				case *ast.ImportSpec:
				case *ast.TypeSpec:
					switch spec.(*ast.TypeSpec).Type.(type) {
					case *ast.StructType:
						typeSpec := spec.(*ast.TypeSpec)
						structType := typeSpec.Type.(*ast.StructType)
						structs[typeSpec.Name.Name] = structType
					}
				}
			}
		}
	}
	structToParse := structs[structName]

	holder.PackageName = node.Name.Name
	holder.StructName = structName
	holder.StructPrefixName = strings.ToLower(structName[:2])
	holder.Fields = make([]Field, len(structToParse.Fields.List))
	holder.StructFieldLen = len(structToParse.Fields.List)

	for i, field := range structToParse.Fields.List {
		// set field name
		holder.Fields[i].Name = field.Names[0].Name
		// set map key
		if opts.SnakeCase {
			holder.Fields[i].MapKey = camelToSnake(field.Names[0].Name)
		} else {
			holder.Fields[i].MapKey = field.Names[0].Name
		}
		// set field type and check if it is zero or nil
		switch field.Type.(type) {
		case *ast.Ident:
			// handle basic types
			fieldType := field.Type.(*ast.Ident)

			switch fieldType.Name {
			case "int", "int8", "int16", "int32", "int64":
				// handle integer types
				holder.Fields[i].CheckZeroOrNil = " != 0"
			case "uint", "uint8", "uint16", "uint32", "uint64", "uintptr":
				// handle unsigned integer types
				holder.Fields[i].CheckZeroOrNil = " != 0"
			case "float32", "float64":
				// handle floating point types
				holder.Fields[i].CheckZeroOrNil = " != 0"
			case "complex64", "complex128":
				// handle complex types
				holder.Fields[i].CheckZeroOrNil = " != 0"
			case "string":
				// handle string types
				holder.Fields[i].CheckZeroOrNil = " != \"\""
			case "bool":
				// handle boolean types
				holder.Fields[i].CheckZeroOrNil = ""
			}

			if fieldType.Obj != nil {
				holder.Fields[i].IsObj = true
			}
		case *ast.StarExpr:
			// handle pointer types
			holder.Fields[i].CheckZeroOrNil = " != nil"
			holder.Fields[i].Dereference = "*"
		case *ast.SelectorExpr:
			// handle custom types

			fieldType := field.Type.(*ast.SelectorExpr)
			fieldTypeX := fieldType.X.(*ast.Ident)
			// handle for guregu/null types
			if fieldTypeX.Name == "null" {
				holder.Fields[i].CheckZeroOrNil = ".Valid"

				switch fieldType.Sel.Name {
				case "Int":
					holder.Fields[i].GureguNullValue = ".Int64"
				case "Float":
					holder.Fields[i].GureguNullValue = ".Float64"
				case "String":
					holder.Fields[i].GureguNullValue = ".String"
				case "Bool":
					holder.Fields[i].GureguNullValue = ".Bool"
				case "Time":
					holder.Fields[i].GureguNullValue = ".Time"
				}
			} else {
				// unknown object
				holder.Fields[i].IsObj = true
			}
		}
	}

	return holder
}

func writeHolderToFile(holder TemplatePlaceholder, sourceFile string) (err error) {
	packagePath := sourceFile[:strings.LastIndex(sourceFile, "/")+1]
	fileName := strings.Replace(sourceFile[strings.LastIndex(sourceFile, "/")+1:], ".go", "_"+strings.ToLower(holder.StructName)+"_gen.go", -1)

	tmpl, err := template.New("templateMethodMapTo").Parse(templateMethodMapTo)
	if err != nil {
		err = errors.New("Error parsing template: " + err.Error())
		return err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, holder)
	if err != nil {
		err = errors.New("Error executing template: " + err.Error())
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		err = errors.New("Error formatting generated code: " + err.Error())
		return err
	}

	err = os.WriteFile(packagePath+fileName, formatted, 0644)
	if err != nil {
		err = errors.New("Error writing generated file: " + err.Error())
		return err
	}

	return nil
}
func camelToSnake(s string) string {
	var result []rune
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				result = append(result, '_')
			}
			result = append(result, unicode.ToLower(r))
		} else {
			result = append(result, r)
		}
	}
	return string(result)
}
